#!/usr/bin/env python3
# -*- coding: utf-8; mode: python; py-indent-offset: 4; py-continuation-offset: 4 -*-
"""
Helper functions for testing
"""
import os

#===============================================================================
#
# Mock Helpers
#
#===============================================================================



def mock_function_noreturn(*args, **kwargs):
    """
    Mock a function that does not return a value (i.e., returns NoneType)
    """
    print("\nmock> f({}) ==> NoneType".format(args)) # pragma: no cover



def mock_function_pass(*args, **kwargs):
    """
    Mock a function that 'passes', i.e., returns a 0.
    """
    print("\nmock> f({}) ==> 0".format(args)) # pragma: no cover
    return 0                                  # pragma: no cover



def mock_function_fail(*args, **kwargs):
    """
    Mock a function that 'fails', i.e., returns a 1.
    """
    print("\nmock> f({}) ==> 1".format(args)) # pragma: no cover
    return 1                                  # pragma: no cover



def mock_distutils_spawn_find_executable_NotFound(*args, **kwargs):
    """
    Mock a call to ``distutils.spawn.find_executable()`` that returns None

    Usage:
        >>> with patch("distutils.spawn.find_executable",
                       side_effect='mock_distutils_spawn_find_executable_NotFound'):
                # call function
            # check # of times mocked function was called or test data

    """
    print("[mock] distutils.spawn.find_executable - NotFound")
    #if True: raise FileNotFoundError("Generated by MOCK")
    return None



def mock_shutil_which_None(*args, **kwargs):
    """
    Mock a call to ``shutil.which()`` that returns None
    """
    print("[mock] shutil.which - NotFound")
    #if True: raise FileNotFoundError("Generated by MOCK")
    return None



class mock_popen(object):
    """
    Abstract base class for popen mock
    """

    def __init__(self, cmd, stdout=None, stderr=None):
        print("mock_popen> {}".format(cmd))
        self.stdout = stdout
        self.stderr = stderr
        self.returncode = None

    def communicate(self):
        print("mock_popen> communicate()")
        stdout = b"os.environ['__foobar__'] ='baz'\ndel os.environ['__foobar__']"
        stderr = b"stderr=1"
        self.returncode = 0
        return (stdout, stderr)



class mock_popen_status_ok(mock_popen):
    """
    Specialization of popen mock that will return with success.
    """

    def __init__(self, cmd, stdout=None, stderr=None):
        super(mock_popen_status_ok, self).__init__(cmd, stdout, stderr)



class mock_popen_status_error_rc0(mock_popen):
    """
    Specialization of popen mock.

    Simulates the results from a modulecmd operation that had
    an error loading a module (maybe not found). Modulecmd will tend
    to have a message like "ERROR: could not load module" in its stderr
    field but it will generally return an exit status of 0.
    """

    def __init__(self, cmd, stdout=None, stderr=None):
        super(mock_popen_status_error_rc0, self).__init__(cmd, stdout, stderr)

    def communicate(self):
        print("mock_popen> communicate()")
        stdout = b"_mlstatus = False\n"
        stderr = b"ERROR: Unable to locate a modulefile for 'gcc/1.2.3'\n"
        self.returncode = 0
        return (stdout, stderr)



class mock_popen_status_error_rc1(mock_popen):
    """
    Specialization of popen mock that will return with error.

    Test the condition where modulecmd returned a status of 1 and
    has `ERROR:` in its stderr field.
    """

    def __init__(self, cmd, stdout=None, stderr=None):
        super(mock_popen_status_error_rc1, self).__init__(cmd, stdout, stderr)

    def communicate(self):
        print("mock_popen> communicate()")
        stdout = b"_mlstatus = False\n"
        stderr = b"ERROR: Unable to locate a modulefile for 'gcc/1.2.3'\n"
        self.returncode = 1
        return (stdout, stderr)



#===============================================================================
#
# General Utility Functions
#
#===============================================================================



def find_config_ini(filename="config.ini", rootpath="."):
    """
    Recursively searches for a particular file among the subdirectory structure.
    If we find it, then we return the full relative path to `pwd` to that file.

    The _first_ match will be returned.

    Args:
        filename (str): The _filename_ of the file we're searching for. Default: 'config.ini'
        rootpath (str): The _root_ path where we will begin our search from. Default: '.'

    Returns:
        String containing the path to the file if it was found. If a matching filename is not
        found then `None` is returned.

    """
    output = None
    for dirpath, dirnames, filename_list in os.walk(rootpath):
        if filename in filename_list:
            output = os.path.join(dirpath, filename)
            break
    if output is None:
        raise FileNotFoundError("Unable to find {} in {}".format(filename, os.getcwd())) # pragma: no cover
    return output
